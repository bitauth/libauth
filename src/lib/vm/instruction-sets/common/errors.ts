import { formatError } from '../../../format/format.js';
import type { AuthenticationProgramStateError } from '../../../lib.js';

export enum AuthenticationErrorCommon {
  calledReserved = 'Program called an unassigned, reserved operation.',
  calledReturn = 'Program called an OP_RETURN operation.',
  calledUpgradableNop = 'Program called a disallowed upgradable non-operation (OP_NOP1-OP_NOP10).',
  checkSequenceUnavailable = 'Program called an OP_CHECKSEQUENCEVERIFY operation, but OP_CHECKSEQUENCEVERIFY requires transaction version 2 or higher.',
  disabledOpcode = 'Program contains a disabled opcode.',
  divisionByZero = 'Program attempted to divide a number by zero.',
  emptyAlternateStack = 'Tried to read from an empty alternate stack.',
  emptyStack = 'Tried to read from an empty stack.',
  exceededMaximumBytecodeLengthLocking = 'The provided locking bytecode exceeds the maximum bytecode length.',
  exceededMaximumBytecodeLengthUnlocking = 'The provided unlocking bytecode exceeds the maximum bytecode length.',
  exceededMaximumVmNumberByteLength = 'Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length.',
  exceededMaximumControlStackDepth = 'Program exceeded the maximum control stack depth.',
  exceededMaximumSignatureCheckCount = 'Program exceeded the maximum signature check count.',
  exceededMaximumStackDepth = 'Program exceeded the maximum stack depth.',
  exceededMaximumStackItemLength = 'Program attempted to push a stack item that exceeded the maximum stack item length.',
  exceededMaximumOperationCount = 'Program exceeded the maximum operation count (201 operations).',
  exceedsMaximumMultisigPublicKeyCount = 'Program called an OP_CHECKMULTISIG that exceeds the maximum public key count (20 public keys).',
  failedVerify = 'Program failed an OP_VERIFY operation.',
  invalidStackIndex = 'Tried to read from an invalid stack index.',
  incompatibleLocktimeType = 'Program called an OP_CHECKLOCKTIMEVERIFY operation with an incompatible locktime type. The transaction locktime and required locktime must both refer to either a block height or a block time.',
  incompatibleSequenceType = 'Program called an OP_CHECKSEQUENCEVERIFY operation with an incompatible sequence type flag. The input sequence number and required sequence number must both use the same sequence locktime type.',
  insufficientLength = 'Program called an OP_NUM2BIN operation with an insufficient byte length to re-encode the provided number.',
  insufficientPublicKeys = 'Program called an OP_CHECKMULTISIG operation that requires signatures from more public keys than are provided.',
  invalidCheckBitsValue = 'Program called an OP_CHECKMULTISIG operation with an invalid CheckBits value.',
  invalidCheckBitsSignatureCount = 'Program called an OP_CHECKMULTISIG operation with a CheckBits value configuring validation for an incorrect number of signatures.',
  invalidNaturalNumber = 'Invalid input: the key/signature count inputs for OP_CHECKMULTISIG require a natural number (n > 0).',
  invalidPublicKeyEncoding = 'Encountered an improperly encoded public key.',
  invalidVmNumber = 'Invalid input: this operation requires a valid VM Number.',
  invalidSignatureEncoding = 'Encountered an improperly encoded signature.',
  invalidSplitIndex = 'Program called an OP_SPLIT operation with an invalid index.',
  invalidTransactionInputIndex = 'Program attempted to read from an invalid transaction input index.',
  invalidTransactionOutputIndex = 'Program attempted to read from an invalid transaction output index.',
  invalidTransactionUtxoIndex = 'Program attempted to read from an invalid transaction UTXO index.',
  locktimeDisabled = 'Program called an OP_CHECKLOCKTIMEVERIFY operation, but locktime is disabled for this transaction.',
  mismatchedBitwiseOperandLength = 'Program attempted a bitwise operation on operands of different lengths.',
  malformedLockingBytecode = 'The provided locking bytecode is malformed.',
  malformedP2shBytecode = 'Redeem bytecode was malformed prior to P2SH evaluation.',
  malformedPush = 'Program must be long enough to push the requested number of bytes.',
  malformedUnlockingBytecode = 'The provided unlocking bytecode is malformed.',
  negativeLocktime = 'Program called an OP_CHECKLOCKTIMEVERIFY or OP_CHECKSEQUENCEVERIFY operation with a negative locktime.',
  nonEmptyControlStackLockingBytecode = 'The locking bytecode completed with a non-empty control stack.',
  nonEmptyControlStackRedeemBytecode = 'The redeem bytecode completed with a non-empty control stack.',
  nonEmptyControlStackUnlockingBytecode = 'The unlocking bytecode completed with a non-empty control stack.',
  nonMinimalPush = 'Push operations must use the smallest possible encoding.',
  nonNullSignatureFailure = 'Program failed a signature verification with a non-null signature (violating the "NULLFAIL" rule).',
  nonSchnorrSizedSignatureInSchnorrMultiSig = 'Program used a non schnorr-sized signature (65 bytes) in a schnorr OP_CHECKMULTISIG operation.',
  overflowsVmNumberRange = 'Program attempted an arithmetic operation which exceeds the range of VM Numbers.',
  requiresCleanStackLockingBytecode = 'Non-P2SH locking bytecode completed evaluation with an unexpected number of items on the stack (must be exactly 1).',
  requiresCleanStackRedeemBytecode = 'P2SH redeem bytecode completed evaluation with an unexpected number of items on the stack (must be exactly 1).',
  requiresPushOnly = 'Unlocking bytecode may contain only push operations in version 1 and 2 transactions.',
  schnorrSizedSignatureInEcdsaMultiSig = 'Program used a schnorr-sized signature (65 bytes) in a legacy-mode (ECDSA) OP_CHECKMULTISIG operation.',
  tokenValidationExcessiveCommitmentLength = 'Transaction violates token validation: excessive token commitment length.',
  tokenValidationInvalidMintingToken = 'Transaction violates token validation: the transaction outputs include a minting token that is not substantiated by the transaction inputs.',
  tokenValidationExcessiveAmount = 'Transaction violates token validation: the transaction outputs include a sum of fungible tokens for a category exceeding the maximum fungible token amount.',
  tokenValidationInvalidFungibleMint = 'Transaction violates token validation: the transaction creates new fungible tokens for a category without a matching genesis input.',
  tokenValidationOutputsExceedInputs = 'Transaction violates token validation: the sum of fungible tokens in the transaction outputs exceed that of the transaction inputs for a category.',
  tokenValidationExcessiveMutableTokens = 'Transaction violates token validation: the transaction creates more mutable tokens than are available for a category without a matching minting token.',
  tokenValidationExcessiveImmutableTokens = 'Transaction violates token validation: the transaction creates an immutable token for a category without a matching minting token or sufficient mutable tokens.',
  unexpectedElse = 'Encountered an OP_ELSE outside of an OP_IF ... OP_ENDIF block.',
  unexpectedEndIf = 'Encountered an OP_ENDIF that is not following a matching OP_IF.',
  unknownOpcode = 'Called an unknown opcode.',
  unmatchedSequenceDisable = "Program called an OP_CHECKSEQUENCEVERIFY operation requiring the disable flag, but the input's sequence number is missing the disable flag.",
  unmatchedP2shRedeemBytecode = 'The P2SH redeem bytecode provided in this input does not match the hash required by the locking bytecode.',
  unsatisfiedLocktime = "Program called an OP_CHECKLOCKTIMEVERIFY operation that requires a locktime greater than the transaction's locktime.",
  unsatisfiedSequenceNumber = "Program called an OP_CHECKSEQUENCEVERIFY operation that requires a sequence number greater than the input's sequence number.",
  unsuccessfulEvaluation = 'Unsuccessful evaluation: completed with a non-truthy value on top of the stack.',
  verifyFailedExcessiveLength = 'Unable to verify transaction: excessive byte length.',
  verifyFailedInsufficientLength = 'Unable to verify transaction: insufficient byte length.',
  verifyFailedMismatchedSourceOutputs = 'Unable to verify transaction: a single spent output must be provided for each transaction input.',
  verifyFailedNoInputs = 'Unable to verify transaction: transactions must have at least one input.',
  verifyFailedNoOutputs = 'Unable to verify transaction: transactions must have at least one output.',
  verifyFailedInputsExceedMaxMoney = 'Unable to verify transaction: the sum of source output values exceeds the maximum possible satoshi value.',
  verifyFailedOutputsExceedInputs = 'Unable to verify transaction: the sum of transaction output values exceeds the sum of transaction inputs.',
  verifyFailedOutputsExceedMaxMoney = 'Unable to verify transaction: the sum of transaction output values exceeds the maximum possible satoshi value.',
  verifyFailedDuplicateSourceOutputs = 'Unable to verify transaction: the transaction attempts to spend the same outpoint in multiple inputs.',
  verifyFailedInvalidVersion = 'Unable to verify transaction: transaction version must be either 1 or 2.',
  verifyFailedExcessiveSigChecks = 'Unable to verify transaction: excessive cumulative signature check count.',
  verifyStandardFailedExcessiveLength = 'Unable to verify standard transaction: transaction exceeds maximum standard byte length.',
  verifyStandardFailedNonstandardOutput = 'Unable to verify standard transaction: standard transactions may only create standard output types.',
  verifyStandardFailedNonstandardSourceOutput = 'Unable to verify standard transaction: standard transactions may only spend standard output types.',
  verifyStandardFailedDustOutput = 'Unable to verify standard transaction: standard transactions may not have dust outputs.',
  verifyStandardFailedExcessiveDataCarrierBytes = 'Unable to verify standard transaction: excessive data carrier bytes.',
  verifyStandardFailedExcessiveUnlockingBytecodeLength = 'Unable to verify standard transaction: excessive unlocking bytecode length.',
  verifyStandardFailedNonPushUnlockingBytecode = 'Unable to verify standard transaction: unlocking bytecode must only include push operations.',
}

/**
 * Applies the `error` to a `state`.
 *
 * @remarks
 * If the state already has an error, this method does not override it.
 * (Evaluation should end after the first encountered error, so further errors
 * aren't relevant.)
 */
export const applyError = <State extends AuthenticationProgramStateError>(
  state: State,
  errorType: string,
  errorDetails?: string,
): State => ({
  ...state,
  error: state.error ?? formatError(errorType, errorDetails),
});
